// Command genvalidation generates TypeScript validation rules from Go constants.
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/zorak1103/notebook/internal/validation"
)

const outputTemplate = `// Code generated by cmd/genvalidation. DO NOT EDIT.
// Generated at: {{.Timestamp}}

export const MaxSubjectLength = {{.MaxSubjectLength}};
export const MaxParticipantsLength = {{.MaxParticipantsLength}};
export const MaxSummaryLength = {{.MaxSummaryLength}};
export const MaxKeywordsLength = {{.MaxKeywordsLength}};
export const MaxNoteContentLength = {{.MaxNoteContentLength}};
export const MaxConfigKeyLength = {{.MaxConfigKeyLength}};
export const MaxConfigValueLength = {{.MaxConfigValueLength}};

// Helper functions for validation
export function validateLength(value: string | undefined | null, maxLength: number): boolean {
  if (!value) return true;
  return value.length <= maxLength;
}

export function validateSubject(subject: string): boolean {
  return subject.length > 0 && subject.length <= MaxSubjectLength;
}

export function validateParticipants(participants: string | undefined): boolean {
  return validateLength(participants, MaxParticipantsLength);
}

export function validateSummary(summary: string | undefined): boolean {
  return validateLength(summary, MaxSummaryLength);
}

export function validateKeywords(keywords: string | undefined): boolean {
  return validateLength(keywords, MaxKeywordsLength);
}
`

type templateData struct {
	Timestamp             string
	MaxSubjectLength      int
	MaxParticipantsLength int
	MaxSummaryLength      int
	MaxKeywordsLength     int
	MaxNoteContentLength  int
	MaxConfigKeyLength    int
	MaxConfigValueLength  int
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Get output directory path
	outputDir := filepath.Join("frontend", "src", "generated")
	outputPath := filepath.Join(outputDir, "validationRules.ts")

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, 0o750); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create output file
	// #nosec G304 - outputPath is constructed from constants, not user input
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			fmt.Fprintf(os.Stderr, "warning: failed to close output file: %v\n", closeErr)
		}
	}()

	// Prepare template data
	data := templateData{
		Timestamp:             "2026-02-14T00:00:00Z", // Fixed for deterministic output
		MaxSubjectLength:      validation.MaxSubjectLength,
		MaxParticipantsLength: validation.MaxParticipantsLength,
		MaxSummaryLength:      validation.MaxSummaryLength,
		MaxKeywordsLength:     validation.MaxKeywordsLength,
		MaxNoteContentLength:  validation.MaxNoteContentLength,
		MaxConfigKeyLength:    validation.MaxConfigKeyLength,
		MaxConfigValueLength:  validation.MaxConfigValueLength,
	}

	// Parse and execute template
	tmpl, err := template.New("validation").Parse(outputTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	fmt.Printf("Generated validation rules: %s\n", outputPath)
	return nil
}
